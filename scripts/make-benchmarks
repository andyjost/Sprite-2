#!/bin/bash

set -e

function usage {
  cat >&2 << EOF
Builds benchmark programs.

USAGE
    make-benchmarks [-c <config-name>] [-p|q] <benchmark-name> [ ... ]

        -c <config-name>
            The configuration name, which is a file under config.  This is used
            to configure the build.  Defaults to "default".

        -p
            Indicates to compile with preprocessed source.  This can be
            used to simplify debugging and profiling.

        -q
            Work silently.

        <benchmark-name>
            The name of the benchmark to compile.  Must be a directory under
            benchmarks.
EOF
  exit 1;
}

# ====== Parse Arguments ======

BUILD="build"
CONFIG_NAME="default"
QUIET=0

while getopts "c:pq" OPTION
do
  case $OPTION in
    c)
      CONFIG_NAME=$OPTARG
      ;;
    p)
      BUILD="build-pp"
      ;;
    q)
      QUIET=1
      ;;
  esac
done

shift $(($OPTIND - 1))

if [ "$#" == "0" ]; then
  usage
  exit 1
fi

# ====== Configure ======

ROOT=`(cd "\`dirname \"$0\"\`" > /dev/null ; cd ..; pwd)`

# Import the build configuration (sets CFLAGS and INCLUDE).
if [ ! -f $ROOT/config/$CONFIG_NAME ]; then
  echo "Config file \"$CONFIG_NAME\" not found under $ROOT/config" >&2
  exit 1
fi

. $ROOT/config/$CONFIG_NAME


for BENCHMARK_NAME in $@
do

  if [[ $QUIET -eq 0 ]]; then
      echo
      echo "------ Building benchmark \"$BENCHMARK_NAME\" with config \"$CONFIG_NAME\" ------"
  fi
  
  # ====== Get the Benchmark ======
  
  if [ ! -d $ROOT/benchmarks/$BENCHMARK_NAME ]; then
    echo "Benchmark directory \"$BENCHMARK_NAME\" not found under $ROOT/benchmarks" >&2
    exit 1
  fi
  
  # The object root holds every output of the build.
  OBJECT_ROOT="$ROOT/object_root"
  mkdir -p $OBJECT_ROOT
  
  OUTDIR=$OBJECT_ROOT/$BENCHMARK_NAME/$CONFIG_NAME
  rm -rf $OUTDIR 2> /dev/null
  mkdir -p $OUTDIR
  
  # Generate the main source file.
  cat > $OUTDIR/main.cpp <<EOF
#include "sprite/sprite.hpp"
#include "benchmarks/$BENCHMARK_NAME/module.hpp"
#include "src/sprite.cpp" // quick-n-dirty, instead of building a lib

int main()
{
  using namespace sprite;
  using sprite::root;
  root = new module::$BENCHMARK_NAME::MainNode();
  root->N();
  root->show();
  std::cout << std::endl;
  return 0;
}
EOF
  
  
  # ====== Build ======
  
  EXE=$OUTDIR/benchmark-$BENCHMARK_NAME
  
  # Use preprocessed source to make debugging and profiling easier.
  function build-pp {
    CMD="g++ $OUTDIR/main.cpp -E -P -o $OUTDIR/sprite.ii -I$ROOT $INCLUDE $CFLAGS \
        | tee $OUTDIR/build.log"
    if [[ $QUIET -eq 0 ]]; then
      echo $CMD
    fi
    eval $CMD
  
    # Reformat the source.  This breaks up the long lines resulting from deep
    # macro expansions, to ease debugging.
    # cp $OUTDIR/sprite.ii $OUTDIR/sprite.ii.orig
    $ROOT/scripts/reformat $OUTDIR/sprite.ii
  
    # Add -fno-omit-frame-pointer to use %rbp for the frame pointer.
    CMD="g++ $OUTDIR/sprite.ii -o $EXE $CFLAGS 2>&1 | tee -a $OUTDIR/build.log"
    if [[ $QUIET -eq 0 ]]; then
      echo $CMD
    fi
    eval $CMD
  }
  
  # Normal build.
  function build {
    CMD="g++ $OUTDIR/main.cpp -o $EXE -I$ROOT $INCLUDE $CFLAGS 2>&1 \
        | tee $OUTDIR/build.log"
    if [[ $QUIET -eq 0 ]]; then
      echo $CMD
    fi
    eval $CMD
  }
  
  $BUILD

done
