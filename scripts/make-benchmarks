#!/bin/bash

function usage {
  cat >&2 << EOF
Builds a benchmark program.

USAGE
    make-benchmarks [-c <config-name>] [-p|q] <benchmark-name> [ ... ]

        -c <config-name>
            The name of a file under config, which is used to configure the
            build.  Defaults to "default".

        -p
            Indicates to compile with preprocessed source.  This can be
            used to simplify debugging and profiling.

        -q
            Work silently.

        <benchmark-name>
            The name of the benchmark to compile.  Must be directory under
            benchmarks.

The executable file will be placed under bin.
EOF
  exit 1;
}

# ====== Parse Arguments ======

BUILD="build"
CONFIG_FILE_NAME="default"
QUIET=0

while getopts "c:pq" OPTION
do
  case $OPTION in
    c)
      CONFIG_FILE_NAME=$OPTARG
      ;;
    p)
      BUILD="build-pp"
      ;;
    q)
      QUIET=1
      ;;
  esac
done

shift $(($OPTIND - 1))

if [ "$#" == "0" ]; then
  usage
  exit 1
fi

# ====== Configure ======

ROOT=`(cd "\`dirname \"$0\"\`" > /dev/null ; cd ..; pwd)`

# Import the build configuration (sets CFLAGS and INCLUDE).
if [ ! -f $ROOT/config/$CONFIG_FILE_NAME ]; then
  echo "Config file \"$CONFIG_FILE_NAME\" not found under $ROOT/config" >&2
  exit 1
fi

. $ROOT/config/$CONFIG_FILE_NAME


for BENCHMARK_NAME in $@
do

  if [[ $QUIET -eq 0 ]]; then
      echo
      echo "------ Building benchmark \"$BENCHMARK_NAME\" ------"
  fi
  
  # ====== Get the Benchmark ======
  
  if [ ! -d $ROOT/benchmarks/$BENCHMARK_NAME ]; then
    echo "Benchmark directory \"$BENCHMARK_NAME\" not found under $ROOT/benchmarks" >&2
    exit 1
  fi
  
  # The object root holds every output of the build.
  OBJECT_ROOT="$ROOT/object_root"
  mkdir -p $OBJECT_ROOT
  
  OUTDIR=$OBJECT_ROOT/$BENCHMARK_NAME
  rm -rf $OUTDIR 2> /dev/null
  mkdir $OUTDIR
  
  # Generate the main source file.
  cat > $OUTDIR/main.cpp <<EOF
#include "sprite/sprite.hpp"
#include "benchmarks/$BENCHMARK_NAME/module.hpp"
#include "src/sprite.cpp" // quick-n-dirty, instead of building a lib

int main()
{
  using namespace sprite;
  using sprite::root;
  root = new $BENCHMARK_NAME::MainNode();
  root->N();
  root->show();
  std::cout << std::endl;
  return 0;
}
EOF
  
  
  # ====== Build ======
  
  EXE=$OUTDIR/benchmark-$BENCHMARK_NAME
  
  # Use preprocessed source to make debugging and profiling easier.
  function build-pp {
    CMD="g++ $OUTDIR/main.cpp -E -P -o $OUTDIR/sprite.ii -I$ROOT $INCLUDE $CFLAGS \
        | tee $OUTDIR/log"
    if [[ $QUIET -eq 0 ]]; then
      echo $CMD
    fi
    eval $CMD
  
    # The dumbest source reformatter ever.  Add a newline after every instance of
    # any of the three characters ;{}.  Ignore asm directives or there will be
    # errors.
    perl -pi -e 'next if /__asm__/; s/([\;\{\}])/$1\n/g;' $OUTDIR/sprite.ii
  
    # Add -fno-omit-frame-pointer to use %rbp for the frame pointer.
    CMD="g++ $OUTDIR/sprite.ii -o $EXE $CFLAGS 2>&1 | tee -a $OUTDIR/log"
    if [[ $QUIET -eq 0 ]]; then
      echo $CMD
    fi
    eval $CMD
  }
  
  # Normal build.
  function build {
    CMD="g++ $OUTDIR/main.cpp -o $EXE -I$ROOT $INCLUDE $CFLAGS 2>&1 \
        | tee $OUTDIR/log"
    if [[ $QUIET -eq 0 ]]; then
      echo $CMD
    fi
    eval $CMD
  }
  
  $BUILD
  
  
  # ====== Install ======
  mkdir -p $ROOT/bin
  cp $EXE $ROOT/bin

done
