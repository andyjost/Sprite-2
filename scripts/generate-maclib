#!/usr/bin/python

# Python Script
# Generates the contents of file sprite/maclib.hpp

### CONFIGURATION ###

# Preprocessor recursion is simulated.  This parameter establishes a limit on
# the depth of any definitional tree.
RECURSION_LIMIT = 8

# This establishes a limit on how many constructors a type may have.
CTOR_LIMIT = 32

### END CONFIGURATION ###


import re
TEXT = []


### NON-RECURSIVE MACROS ###
TEXT.append(
"""
/* Note: This file is automatically generated by scripts/generate_maclib.py */

#include <boost/preprocessor.hpp>

// Constructor Definition (CD)
//   CD = (ident, name, arity) where
//       ident: the C++ identifier
//       name: the node label (a string)
//       arity: the constructor arity

#define NEW_CD(ident,name,arity) (ident,name,arity)
#define CD_IDENT(CD) BOOST_PP_TUPLE_ELEM(3,0,CD)
#define CD_NAME(CD)  BOOST_PP_TUPLE_ELEM(3,1,CD)
#define CD_ARITY(CD) BOOST_PP_TUPLE_ELEM(3,2,CD)

// ======

// Type Definition (TD)
//   TD = (ns, cds) where
//       ns: the namespace where the type is defined; prefix sprite:: is
//           assumed.
//       cds: a sequence of constructor definitions (CDs).

#define NEW_TD(ns,cds) (ns,cds)
#define TD_NS(TD)  BOOST_PP_TUPLE_ELEM(2,0,TD)
#define TD_CDS(TD) BOOST_PP_TUPLE_ELEM(2,1,TD)
// ----
// The length of cds.
#define TD_LEN(TD) BOOST_PP_SEQ_SIZE(TD_CDS(TD))
// Condition an input TD by adjusting the ns.
#define TD_COND(TD) NEW_TD(sprite::TD_NS(TD)::, TD_CDS(TD))

// ======

#define TYPE_III(CD,n)                                      \\
    CONSTRUCTOR(CD_IDENT(CD), CD_NAME(CD), CD_ARITY(CD), n) \\
  /**/
#define TYPE_II(z,n,cds) TYPE_III(BOOST_PP_SEQ_ELEM(n,cds), n)
#define TYPE_I(cds) BOOST_PP_REPEAT(BOOST_PP_SEQ_SIZE(cds),TYPE_II,cds)

// API: TYPE
#define TYPE(TD) TYPE_I(TD_CDS(TD))

// ======

// A0 = (z,name,path,ns,CD) where
//     z: the next available recursion depth for REPEAT
//     name: the function name to generate.
//     path: the path to the current node in the definitional tree (a sequence
//           of ints).
//     ns: the namespace associated with the constructor definition (CD).
//     CD: the constructor definition at the current pdt node.

#define NEW_A0(z,name,path,ns,CD) (z,name,path,ns,CD)
#define A0_Z(A0)    BOOST_PP_TUPLE_ELEM(5,0,A0)
#define A0_NAME(A0) BOOST_PP_TUPLE_ELEM(5,1,A0)
#define A0_PATH(A0) BOOST_PP_TUPLE_ELEM(5,2,A0)
#define A0_NS(A0)   BOOST_PP_TUPLE_ELEM(5,3,A0)
#define A0_CD(A0)   BOOST_PP_TUPLE_ELEM(5,4,A0)
// ----
// Expands to the fully-qualified name of the constructor in A0.
#define A0_CTORNAME(A0) A0_NS(A0) CD_IDENT(A0_CD(A0))

// A1 = (A0,TD,pdts)
//     A0: an A0 structure
//     TD: the type definition (TD) at the current inductive position
//     pdts: an array of pdts derived by removing the root from a previous pdt

#define NEW_A1(A0,TD,pdts) (A0,TD,pdts)
#define A1_A0(A1)   BOOST_PP_TUPLE_ELEM(3,0,A1)
#define A1_TD(A1)   BOOST_PP_TUPLE_ELEM(3,1,A1)
#define A1_PDTS(A1) BOOST_PP_TUPLE_ELEM(3,2,A1)
// ---
#define A1_TO_A0(A1,z,n) A1_TO_A0_I(A1_A0(A1),A1_TD(A1),A1_PDTS(A1),z,n)
#define A1_TO_A0_I(A0,TD,pdts,z,n)            \\
    NEW_A0(                                   \\
        z                                     \\
      , A0_NAME(A0)                           \\
      , BOOST_PP_SEQ_PUSH_BACK(A0_PATH(A0),n) \\
      , TD_NS(TD)                             \\
      , BOOST_PP_SEQ_ELEM(n,TD_CDS(TD))       \\
      )                                       \\
  /**/

#define BEGIN_FUNCTION(A0, suffix) void FUNCTION_NAME(A0, suffix)() {
#define END_FUNCTION }

#define FUNCTION_NAME(A0, suffix) BOOST_PP_CAT(FN_I(A0_NAME(A0),A0_PATH(A0)), suffix)
#define FN_I(name,path) FN_III(name,BOOST_PP_SEQ_POP_FRONT(BOOST_PP_SEQ_TRANSFORM(FN_II,_,path)))
#define FN_II(s,data,elem) BOOST_PP_CAT(data,elem)
#define FN_III(name,path) FN_IV(BOOST_PP_SEQ_PUSH_FRONT(path,name))
#define FN_IV(path) BOOST_PP_SEQ_CAT(path())

#define CALL(macro,A0) BOOST_PP_CAT(macro##_,A0_Z(A0))
#define REPEAT(A0) CALL(REPEAT,A0)

#define DEFINITIONAL_TREE(...)           \\
    DT_START(                            \\
        NEW_A0(1,dt,BOOST_PP_SEQ_NIL,,)  \\
      , TUPLE_TO_ARRAY(((__VA_ARGS__)))) \\
  /**/
#define DT_START(A0,pdts)               \\
    CALL(DT_I,A0)(                      \\
        CALL(DT_II,A0)                  \\
      , A0                              \\
      , NEW_TD(, (NEW_CD(this_type,,))) \\
      , pdts                            \\
      )                                 \\
  /**/

#define DTB_I(A0,pos,TD,...)                                                \\
    /* The number of constructors in type must match the number of extra */ \\
    /* args provided.                                                    */ \\
    BOOST_PP_ASSERT(                                                        \\
        BOOST_PP_EQUAL(TD_LEN(TD), VA_LEN(__VA_ARGS__))                     \\
      )                                                                     \\
                                                                            \\
    /* Define the function to handle this branch in the DTree. */           \\
    static BEGIN_FUNCTION(A0,)                                              \\
      typedef A0_CTORNAME(A0) inductive_type;                               \\
      static procedure vtable[] = { &fail, &fwd, &choice, &oper             \\
          REPEAT(A0)(VA_LEN(__VA_ARGS__),DTB_II,A0)                         \\
        };                                                                  \\
      TABLE_CALL(pos, vtable)                                               \\
    END_FUNCTION                                                            \\
  /**/
#define DTB_II(z,n,A0) , &this_type::FUNCTION_NAME(A0, _##n)

#define DTL(A0,rule)                          \\
    static BEGIN_FUNCTION(A0,)                \\
      typedef A0_CTORNAME(A0) inductive_type; \\
      rule                                    \\
    END_FUNCTION                              \\
  /**/

#define TUPLE_TO_ARRAY(z) (VA_LEN z,z)
"""
)

# The VA_LEN macro must handle up to RECURSION_LIMIT args.  Here's the
# definition for 9 args:
#     #define VA_LEN(...) VA_LEN_I(__VA_ARGS__,9,8,7,6,5,4,3,2,1)
#     #define VA_LEN_I(_1,_2,_3,_4,_5,_6,_7,_8,_9,n,...) n

TEXT.append(
    '#define VA_LEN(...) VA_LEN_I(__VA_ARGS__,'
    + ','.join(str(i) for i in reversed(xrange(1, RECURSION_LIMIT+1)))
    + ')'
  )
TEXT.append(
    '#define VA_LEN_I('
    + ','.join('_' + str(i) for i in xrange(1, RECURSION_LIMIT+1))
    + ',n,...) n'
  )
### END NON-RECURSIVE MACROS ###


### SIMPLE RECURSIVE MACROS ###
RECURSIVE_TEXT = """
#define DT_I_$i(func,A0,TD,pdts) REPEAT(A0)(BOOST_PP_ARRAY_SIZE(pdts),func,NEW_A1(A0,TD,pdts))
#define DT_II_$i(z,n,A1) DT_III_##z(DT_V_##z,A1_TO_A0(A1,z,n),TUPLE_TO_ARRAY(BOOST_PP_ARRAY_ELEM(n,A1_PDTS(A1))))
#define DT_III_$i(func,A0,pdt) CALL(DT_IV,A0)(func BOOST_PP_ARRAY_DATA(BOOST_PP_ARRAY_INSERT(pdt,1,A0)))
#define DT_IV_$i(x) x
#define DT_V_$i(cmd,A0,...) CALL(cmd,A0)(A0,##__VA_ARGS__)
#define DT_BRANCH_$i(A0,pos,TD,...)   \\
    DTB_I(A0,pos,TD,__VA_ARGS__)      \\
    CALL(DT_I,A0)(                    \\
        CALL(DT_II,A0)                \\
      , A0                            \\
      , TD_COND(TD)                   \\
      , TUPLE_TO_ARRAY((__VA_ARGS__)) \\
      )                               \\
  /**/
#define DT_LEAF_$i(A0,rule) DTL(A0,rule)
"""

# Generate the above text RECURSION_LIMIT times.  Replace each instance of $i
# with a serial integer.
ri = re.compile(r'\$i')
for i in xrange(1, RECURSION_LIMIT+1):
  chunk = ri.sub(str(i), RECURSIVE_TEXT)
  TEXT.append(chunk)
### END SIMPLE RECURSIVE MACROS ###


### REPETITION MACRO ###
# The BOOST_PP_REPEAT macro allows only three dimensions.  For this work, the
# number of dimensions limits the depth of any definitional tree, so it must be
# greater than three.  Here is a simple repetition construct.
#
# In this implementation $i, is the repetition dimension, and $j is the
# iteration number.

rj = re.compile(r'\$j')
rp = re.compile(r'\$p') # $p equals $j-1, i.e., the next iteration number
rn = re.compile(r'\$n') # $n equals $i+1, i.e., the next recursion depth
macro0 = '#define REPEAT_$i(c,m,d) REPEAT_$i_I(c,m,d)'
macro1 = '#define REPEAT_$i_I(c,m,d) REPEAT_$i_##c(m,d)'
for i in xrange(1,RECURSION_LIMIT+1):
  chunk = ri.sub(str(i), macro0)
  TEXT.append(chunk)
  chunk = ri.sub(str(i), macro1)
  TEXT.append(chunk)

# Error if the recursion depth is exceeded.
TEXT.append(
    '#define REPEAT_%s(c,m,d) BOOST_PP_ERROR(0x0003)' % (RECURSION_LIMIT+1,)
  )

for i in xrange(1,RECURSION_LIMIT+1):
  macro = '#define REPEAT_$i_0(m,d)'
  chunk = ri.sub(str(i), macro)
  TEXT.append(chunk)

  for j in xrange(1,CTOR_LIMIT+1):
    macro = '#define REPEAT_$i_$j(m,d) REPEAT_$i_$p(m,d) m($n,$p,d)'
    chunk = ri.sub(str(i), macro)
    chunk = rj.sub(str(j), chunk)
    chunk = rp.sub(str(j-1), chunk)
    chunk = rn.sub(str(i+1), chunk)
    TEXT.append(chunk) 
### END REPETITION MACRO ###

print '\n'.join(TEXT)
