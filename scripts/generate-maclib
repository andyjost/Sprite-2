#!/usr/bin/python

# Python Script
# Generates the contents of file sprite/maclib.hpp

### CONFIGURATION ###

# Preprocessor recursion is simulated.  This parameter establishes a limit on
# the depth of any definitional tree.
RECURSION_LIMIT = 8

# This establishes a limit on how many constructors a type may have.
CTOR_LIMIT = 32

### END CONFIGURATION ###


import re
TEXT = []


### NON-RECURSIVE MACROS ###
TEXT.append(
"""
/* Note: This file is automatically generated by scripts/generate_maclib.py */

#include <boost/preprocessor.hpp>

// Constructor Definition (CD)
//   CD = (ident, name, arity) where
//       ident: the C++ identifier
//       name: the node label (a string)
//       arity: the constructor arity

#define CD_IDENT(CD) BOOST_PP_TUPLE_ELEM(3,0,CD)
#define CD_NAME(CD)  BOOST_PP_TUPLE_ELEM(3,1,CD)
#define CD_ARITY(CD) BOOST_PP_TUPLE_ELEM(3,2,CD)

// ======

#define TYPE_II(CD,n)                                       \\
    CONSTRUCTOR(CD_IDENT(CD), CD_NAME(CD), CD_ARITY(CD), n) \\
  /**/
#define TYPE_I(z,n,type) TYPE_II(BOOST_PP_SEQ_ELEM(n,type), n)

// API: TYPE
#define TYPE(type) BOOST_PP_REPEAT(BOOST_PP_SEQ_SIZE(type),TYPE_I,type)

// ======

// A0 = (z,name,path,CD) where
//     z: the next available recursion depth for REPEAT
//     name: the function name to generate
//     path: the path to the current node in the definitional tree (a sequence of ints)
//     CD: the constructor definition at the current pdt node
#define A0(z,name,path,type) (z,name,path,type)
#define A0_Z(A0)    BOOST_PP_TUPLE_ELEM(4,0,A0)
#define A0_NAME(A0) BOOST_PP_TUPLE_ELEM(4,1,A0)
#define A0_PATH(A0) BOOST_PP_TUPLE_ELEM(4,2,A0)
#define A0_CD(A0)   BOOST_PP_TUPLE_ELEM(4,3,A0)

// A1 = (A0,type,pdts)
//     A0: an A0 structure
//     type: the type at the current inductive position
//     pdts: an array of pdts derived by removing the root from a previous pdt

#define A1(A0,type,pdts) (A0,type,pdts)
#define A1_A0(A1)   BOOST_PP_TUPLE_ELEM(3,0,A1)
#define A1_TYPE(A1) BOOST_PP_TUPLE_ELEM(3,1,A1)
#define A1_PDTS(A1) BOOST_PP_TUPLE_ELEM(3,2,A1)
#define A1_TO_A0(A1,z,n) A1_TO_A0_I(A1_A0(A1),A1_TYPE(A1),A1_PDTS(A1),z,n)
#define A1_TO_A0_I(A0,type,pdts,z,n)                                                      \\
    /*A0*/(z,A0_NAME(A0),BOOST_PP_SEQ_PUSH_BACK(A0_PATH(A0),n),BOOST_PP_SEQ_ELEM(n,type)) \\
  /**/

#define BEGIN_FUNCTION(A0, suffix) void FUNCTION_NAME(A0, suffix)() {
#define END_FUNCTION }

#define FUNCTION_NAME(A0, suffix) BOOST_PP_CAT(FN_I(A0_NAME(A0),A0_PATH(A0)), suffix)
#define FN_I(name,path) FN_III(name,BOOST_PP_SEQ_POP_FRONT(BOOST_PP_SEQ_TRANSFORM(FN_II,_,path)))
#define FN_II(s,data,elem) BOOST_PP_CAT(data,elem)
#define FN_III(name,path) FN_IV(BOOST_PP_SEQ_PUSH_FRONT(path,name))
#define FN_IV(path) BOOST_PP_SEQ_CAT(path())

#define CALL(macro,A0) BOOST_PP_CAT(macro##_,A0_Z(A0))
#define REPEAT(A0) CALL(REPEAT,A0)

#define DEFINITIONAL_TREE(...)                                           \\
    DT_START(A0(1,dt,BOOST_PP_SEQ_NIL,),TUPLE_TO_ARRAY(((__VA_ARGS__)))) \\
  /**/
#define DT_START(A0,pdts) CALL(DT_I,A0)(CALL(DT_II,A0),A0,((this_type,,)),pdts)

#define DTB_I(A0,pos,type,...)                                              \\
    /* The number of constructors in type must match the number of extra */ \\
    /* args provided.                                                    */ \\
    BOOST_PP_ASSERT(                                                        \\
        BOOST_PP_EQUAL(BOOST_PP_SEQ_SIZE(type), VA_LEN(__VA_ARGS__))        \\
      )                                                                     \\
                                                                            \\
    /* Define the function to handle this branch in the DTree. */           \\
    static BEGIN_FUNCTION(A0,)                                              \\
      static procedure vtable[] = { &fail, &fwd, &choice, &oper             \\
          REPEAT(A0)(VA_LEN(__VA_ARGS__),DTB_II,A0)                         \\
        };                                                                  \\
      TABLE_CALL(pos, vtable)                                               \\
    END_FUNCTION                                                            \\
  /**/
#define DTB_II(z,n,A0) , &this_type::FUNCTION_NAME(A0, _##n)

#define DTL(A0,rule)                              \\
    static BEGIN_FUNCTION(A0,)                    \\
      typedef CD_IDENT(A0_CD(A0)) inductive_type; \\
      rule                                        \\
    END_FUNCTION                                  \\
  /**/

#define TUPLE_TO_ARRAY(z) (VA_LEN z,z)
"""
)

# The VA_LEN macro must handle up to RECURSION_LIMIT args.  Here's the
# definition for 9 args:
#     #define VA_LEN(...) VA_LEN_I(__VA_ARGS__,9,8,7,6,5,4,3,2,1)
#     #define VA_LEN_I(_1,_2,_3,_4,_5,_6,_7,_8,_9,n,...) n

TEXT.append(
    '#define VA_LEN(...) VA_LEN_I(__VA_ARGS__,'
    + ','.join(str(i) for i in reversed(xrange(1, RECURSION_LIMIT+1)))
    + ')'
  )
TEXT.append(
    '#define VA_LEN_I('
    + ','.join('_' + str(i) for i in xrange(1, RECURSION_LIMIT+1))
    + ',n,...) n'
  )
### END NON-RECURSIVE MACROS ###


### SIMPLE RECURSIVE MACROS ###
RECURSIVE_TEXT = """
#define DT_I_$i(func,A0,type,pdts) REPEAT(A0)(BOOST_PP_ARRAY_SIZE(pdts),func,A1(A0,type,pdts))
#define DT_II_$i(z,n,A1) DT_III_##z(DT_V_##z,A1_TO_A0(A1,z,n),TUPLE_TO_ARRAY(BOOST_PP_ARRAY_ELEM(n,A1_PDTS(A1))))
#define DT_III_$i(func,A0,pdt) CALL(DT_IV,A0)(func BOOST_PP_ARRAY_DATA(BOOST_PP_ARRAY_INSERT(pdt,1,A0)))
#define DT_IV_$i(x) x
#define DT_V_$i(cmd,A0,...) CALL(cmd,A0)(A0,##__VA_ARGS__)
#define DT_BRANCH_$i(A0,pos,type,...)                                   \\
    DTB_I(A0,pos,type,__VA_ARGS__)                                      \\
    CALL(DT_I,A0)(CALL(DT_II,A0),A0,type,TUPLE_TO_ARRAY((__VA_ARGS__))) \\
  /**/
#define DT_LEAF_$i(A0,rule) DTL(A0,rule)
"""

# Generate the above text RECURSION_LIMIT times.  Replace each instance of $i
# with a serial integer.
ri = re.compile(r'\$i')
for i in xrange(1, RECURSION_LIMIT+1):
  chunk = ri.sub(str(i), RECURSIVE_TEXT)
  TEXT.append(chunk)
### END SIMPLE RECURSIVE MACROS ###


### REPETITION MACRO ###
# The BOOST_PP_REPEAT macro allows only three dimensions.  For this work, the
# number of dimensions limits the depth of any definitional tree, so it must be
# greater than three.  Here is a simple repetition construct.
#
# In this implementation $i, is the repetition dimension, and $j is the
# iteration number.

rj = re.compile(r'\$j')
rp = re.compile(r'\$p') # $p equals $j-1, i.e., the next iteration number
rn = re.compile(r'\$n') # $n equals $i+1, i.e., the next recursion depth
macro0 = '#define REPEAT_$i(c,m,d) REPEAT_$i_I(c,m,d)'
macro1 = '#define REPEAT_$i_I(c,m,d) REPEAT_$i_##c(m,d)'
for i in xrange(1,RECURSION_LIMIT+1):
  chunk = ri.sub(str(i), macro0)
  TEXT.append(chunk)
  chunk = ri.sub(str(i), macro1)
  TEXT.append(chunk)

# Error if the recursion depth is exceeded.
TEXT.append(
    '#define REPEAT_%s(c,m,d) BOOST_PP_ERROR(0x0003)' % (RECURSION_LIMIT+1,)
  )

for i in xrange(1,RECURSION_LIMIT+1):
  macro = '#define REPEAT_$i_0(m,d)'
  chunk = ri.sub(str(i), macro)
  TEXT.append(chunk)

  for j in xrange(1,CTOR_LIMIT+1):
    macro = '#define REPEAT_$i_$j(m,d) REPEAT_$i_$p(m,d) m($n,$p,d)'
    chunk = ri.sub(str(i), macro)
    chunk = rj.sub(str(j), chunk)
    chunk = rp.sub(str(j-1), chunk)
    chunk = rn.sub(str(i+1), chunk)
    TEXT.append(chunk) 
### END REPETITION MACRO ###

print '\n'.join(TEXT)
