#!/usr/bin/python

# Python Script
# Generates the contents of file sprite/maclib.hpp

### CONFIGURATION ###

# Preprocessor recursion is simulated.  This parameter establishes a limit on
# the depth of any definitional tree.
RECURSION_LIMIT = 8

# This establishes a limit on how many constructors a type may have.
CTOR_LIMIT = 32

### END CONFIGURATION ###


import re
TEXT = []


### NON-RECURSIVE MACROS ###
TEXT.append(
"""
/* Note: This file is automatically generated by scripts/generate_maclib.py */

#include <boost/preprocessor.hpp>

// Constructor Definition (CD)
//   CD = (ident, name, arity) where
//       ident: the C++ identifier
//       name: the node label (a string)
//       arity: the constructor arity

#define NEW_CD(ident,name,arity) (ident,name,arity)
#define CD_IDENT(CD) BOOST_PP_TUPLE_ELEM(3,0,CD)
#define CD_NAME(CD)  BOOST_PP_TUPLE_ELEM(3,1,CD)
#define CD_ARITY(CD) BOOST_PP_TUPLE_ELEM(3,2,CD)

// ======

// Type Definition (TD)
//   TD = (ns, cds) where
//       ns: the namespace where the type is defined; prefix sprite:: is
//           assumed.
//       cds: a sequence of constructor definitions (CDs).

#define NEW_TD(ns,cds) (ns,cds)
#define TD_NS(TD)  BOOST_PP_TUPLE_ELEM(2,0,TD)
#define TD_CDS(TD) BOOST_PP_TUPLE_ELEM(2,1,TD)
// ----
// The length of cds.
#define TD_LEN(TD) BOOST_PP_SEQ_SIZE(TD_CDS(TD))
// Condition an input TD by adjusting the ns.
#define TD_COND(TD) NEW_TD(sprite::TD_NS(TD)::, TD_CDS(TD))

// ======

#define TYPE_III(CD,n)                                      \\
    CONSTRUCTOR(CD_IDENT(CD), CD_NAME(CD), CD_ARITY(CD), n) \\
  /**/
#define TYPE_II(z,n,cds) TYPE_III(BOOST_PP_SEQ_ELEM(n,cds), n)
#define TYPE_I(cds) BOOST_PP_REPEAT(BOOST_PP_SEQ_SIZE(cds),TYPE_II,cds)

// API: TYPE
#define TYPE(TD) TYPE_I(TD_CDS(TD))

// ======

// A0 = (z,path,ns,CD,mbranch,mleaf) where
//     z: the next available recursion depth for REPEAT
//     path: the path to the current node in the definitional tree (a sequence
//           of ints).
//     ns: the namespace associated with the constructor definition (CD).
//     CD: the constructor definition at the current pdt node.
//     mbranch: the macro function to invoke when a branch is encountered.  The
//              arguments will be (A0,pos,TD,...), where the variadic arguments
//              are the child pdts.
//     mleaf: the macro function to invoke when a leaf is encountered.  The
//              arguments will be (A0,rule), where rule is the user-supplied
//              rewrite rule.

#define NEW_A0(z,path,ns,CD,mbranch,mleaf) (z,path,ns,CD,mbranch,mleaf)
#define A0_Z(A0)       BOOST_PP_TUPLE_ELEM(6,0,A0)
#define A0_PATH(A0)    BOOST_PP_TUPLE_ELEM(6,1,A0)
#define A0_NS(A0)      BOOST_PP_TUPLE_ELEM(6,2,A0)
#define A0_CD(A0)      BOOST_PP_TUPLE_ELEM(6,3,A0)
#define A0_MBRANCH(A0) BOOST_PP_TUPLE_ELEM(6,4,A0)
#define A0_MLEAF(A0)   BOOST_PP_TUPLE_ELEM(6,5,A0)
// ----
// Expands to the fully-qualified name of the constructor in A0.
#define A0_CTORNAME(A0) A0_NS(A0)CD_IDENT(A0_CD(A0))

// A1 = (A0,TD,pdts)
//     A0: an A0 structure
//     TD: the type definition (TD) at the current inductive position
//     pdts: an array of pdts derived by removing the root from a previous pdt

#define NEW_A1(A0,TD,pdts) (A0,TD,pdts)
#define A1_A0(A1)   BOOST_PP_TUPLE_ELEM(3,0,A1)
#define A1_TD(A1)   BOOST_PP_TUPLE_ELEM(3,1,A1)
#define A1_PDTS(A1) BOOST_PP_TUPLE_ELEM(3,2,A1)
// ---
#define A1_TO_A0(A1,z,n) A1_TO_A0_I(A1_A0(A1),A1_TD(A1),A1_PDTS(A1),z,n)
#define A1_TO_A0_I(A0,TD,pdts,z,n)            \\
    NEW_A0(                                   \\
        z                                     \\
      , BOOST_PP_SEQ_PUSH_BACK(A0_PATH(A0),n) \\
      , TD_NS(TD)                             \\
      , BOOST_PP_SEQ_ELEM(n,TD_CDS(TD))       \\
      , A0_MBRANCH(A0)                        \\
      , A0_MLEAF(A0)                          \\
      )                                       \\
  /**/

// Builds an identifier that includes the path (taken from A0).
#define IDENTIFIER(base,A0,suffix) BOOST_PP_CAT(ID_I(base,A0_PATH(A0)),suffix)
#define ID_I(name,path) ID_III(name,BOOST_PP_SEQ_POP_FRONT(BOOST_PP_SEQ_TRANSFORM(ID_II,_,path)))
#define ID_II(s,data,elem) BOOST_PP_CAT(data,elem)
#define ID_III(name,path) ID_IV(BOOST_PP_SEQ_PUSH_FRONT(path,name))
#define ID_IV(path) BOOST_PP_SEQ_CAT(path())

#define CALL(macro,A0) BOOST_PP_CAT(macro##_,A0_Z(A0))
#define REPEAT(A0) CALL(REPEAT,A0)

// Recursively expands a definitional tree specification.  mbranch is a macro
// that is called for each branch.  mleaf is a macro that is called for each
// leaf.  dtree is the definitional tree specification.
#define DEFINITIONAL_TREE(mbranch,mleaf,dtree)      \\
    DT_START(                                       \\
        NEW_A0(1,BOOST_PP_SEQ_NIL,,,mbranch,mleaf)  \\
      , TUPLE_TO_ARRAY((dtree))                     \\
      )
  /**/
#define DT_START(A0,pdts)               \\
    CALL(DT_I,A0)(                      \\
        CALL(DT_II,A0)                  \\
      , A0                              \\
      , NEW_TD(, (NEW_CD(this_type,,))) \\
      , pdts                            \\
      )                                 \\
  /**/

#define TUPLE_TO_ARRAY(z) (VA_LEN z,z)
#define VA_HEAD(head,...) head
"""
)

# The VA_LEN macro must handle up to RECURSION_LIMIT args.  Here's the
# definition for 9 args:
#     #define VA_LEN(...) VA_LEN_I(__VA_ARGS__,9,8,7,6,5,4,3,2,1)
#     #define VA_LEN_I(_1,_2,_3,_4,_5,_6,_7,_8,_9,n,...) n

TEXT.append(
    '#define VA_LEN(...) VA_LEN_I(__VA_ARGS__,'
    + ','.join(str(i) for i in reversed(xrange(1, RECURSION_LIMIT+1)))
    + ')'
  )
TEXT.append(
    '#define VA_LEN_I('
    + ','.join('_' + str(i) for i in xrange(1, RECURSION_LIMIT+1))
    + ',n,...) n'
  )
### END NON-RECURSIVE MACROS ###


### SIMPLE RECURSIVE MACROS ###
RECURSIVE_TEXT = """
#define DT_I_$i(func,A0,TD,pdts) REPEAT(A0)(BOOST_PP_ARRAY_SIZE(pdts),func,NEW_A1(A0,TD,pdts))
#define DT_II_$i(z,n,A1) DT_III_##z(DT_V_##z,A1_TO_A0(A1,z,n),TUPLE_TO_ARRAY(BOOST_PP_ARRAY_ELEM(n,A1_PDTS(A1))))
#define DT_III_$i(func,A0,pdt) CALL(DT_IV,A0)(func BOOST_PP_ARRAY_DATA(BOOST_PP_ARRAY_INSERT(pdt,1,A0)))
#define DT_IV_$i(x) x
#define DT_V_$i(cmd,A0,...) CALL(cmd,A0)(A0,##__VA_ARGS__)
#define DT_BRANCH_$i(A0,pos,TD,...)       \\
    A0_MBRANCH(A0)(A0,pos,TD,__VA_ARGS__) \\
    CALL(DT_I,A0)(                        \\
        CALL(DT_II,A0)                    \\
      , A0                                \\
      , TD_COND(TD)                       \\
      , TUPLE_TO_ARRAY((__VA_ARGS__))     \\
      )                                   \\
  /**/
#define DT_LEAF_$i(A0,rule) A0_MLEAF(A0)(A0,rule)
"""

# Generate the above text RECURSION_LIMIT times.  Replace each instance of $i
# with a serial integer.
ri = re.compile(r'\$i')
for i in xrange(1, RECURSION_LIMIT+1):
  chunk = ri.sub(str(i), RECURSIVE_TEXT)
  TEXT.append(chunk)
### END SIMPLE RECURSIVE MACROS ###


### REPETITION MACRO ###
# The BOOST_PP_REPEAT macro allows only three dimensions.  For this work, the
# number of dimensions limits the depth of any definitional tree, so it must be
# greater than three.  Here is a simple repetition construct.
#
# In this implementation $i, is the repetition dimension, and $j is the
# iteration number.

rj = re.compile(r'\$j')
rp = re.compile(r'\$p') # $p equals $j-1, i.e., the next iteration number
rn = re.compile(r'\$n') # $n equals $i+1, i.e., the next recursion depth
macro0 = '#define REPEAT_$i(c,m,d) REPEAT_$i_I(c,m,d)'
macro1 = '#define REPEAT_$i_I(c,m,d) REPEAT_$i_##c(m,d)'
for i in xrange(1,RECURSION_LIMIT+1):
  chunk = ri.sub(str(i), macro0)
  TEXT.append(chunk)
  chunk = ri.sub(str(i), macro1)
  TEXT.append(chunk)

# Error if the recursion depth is exceeded.
TEXT.append(
    '#define REPEAT_%s(c,m,d) BOOST_PP_ERROR(0x0003)' % (RECURSION_LIMIT+1,)
  )

for i in xrange(1,RECURSION_LIMIT+1):
  macro = '#define REPEAT_$i_0(m,d)'
  chunk = ri.sub(str(i), macro)
  TEXT.append(chunk)

  for j in xrange(1,CTOR_LIMIT+1):
    macro = '#define REPEAT_$i_$j(m,d) REPEAT_$i_$p(m,d) m($n,$p,d)'
    chunk = ri.sub(str(i), macro)
    chunk = rj.sub(str(j), chunk)
    chunk = rp.sub(str(j-1), chunk)
    chunk = rn.sub(str(i+1), chunk)
    TEXT.append(chunk) 
### END REPETITION MACRO ###

print '\n'.join(TEXT)
